/**
 * Export Verification Key for Soroban Contract
 *
 * This script reads the verification key generated by snarkjs and
 * converts it to the format expected by the Soroban contract.
 *
 * Usage: node scripts/export_vk.js
 */

const fs = require('fs');
const path = require('path');

const buildDir = path.join(__dirname, '..', 'build');
const vkPath = path.join(buildDir, 'verification_key.json');

if (!fs.existsSync(vkPath)) {
    console.error('Error: verification_key.json not found.');
    console.error('Run the circuit build first: npm run build');
    process.exit(1);
}

const vk = JSON.parse(fs.readFileSync(vkPath, 'utf8'));

console.log('Verification Key Export for Soroban Contract');
console.log('=============================================\n');

// The verification key structure expected by the Soroban contract:
// - alpha: G1 point (48 bytes)
// - beta: G2 point (96 bytes)
// - gamma: G2 point (96 bytes)
// - delta: G2 point (96 bytes)
// - ic: Array of G1 points (48 bytes each)

console.log('Raw Verification Key (snarkjs format):');
console.log('--------------------------------------');
console.log('vk_alpha_1:', vk.vk_alpha_1);
console.log('vk_beta_2:', vk.vk_beta_2);
console.log('vk_gamma_2:', vk.vk_gamma_2);
console.log('vk_delta_2:', vk.vk_delta_2);
console.log('IC length:', vk.IC.length);

// Convert snarkjs format to hex bytes
function g1PointToHex(point) {
    // snarkjs gives [x, y, z] in decimal string format
    // We need to convert to big-endian bytes
    const x = BigInt(point[0]);
    const y = BigInt(point[1]);

    // For BLS12-381 G1 points, x and y are 48 bytes each (384 bits)
    const xHex = x.toString(16).padStart(96, '0');
    const yHex = y.toString(16).padStart(96, '0');

    return xHex + yHex;
}

function g2PointToHex(point) {
    // snarkjs gives [[x0, x1], [y0, y1], [z0, z1]] in decimal string format
    // G2 point in BLS12-381 has Fp2 coordinates
    const x0 = BigInt(point[0][0]);
    const x1 = BigInt(point[0][1]);
    const y0 = BigInt(point[1][0]);
    const y1 = BigInt(point[1][1]);

    // Each coordinate is 48 bytes
    const x0Hex = x0.toString(16).padStart(96, '0');
    const x1Hex = x1.toString(16).padStart(96, '0');
    const y0Hex = y0.toString(16).padStart(96, '0');
    const y1Hex = y1.toString(16).padStart(96, '0');

    return x0Hex + x1Hex + y0Hex + y1Hex;
}

console.log('\n');
console.log('Decimal Values for Soroban Contract (use these in Rust):');
console.log('--------------------------------------------------------');
console.log('\nalpha (G1):');
console.log('  x:', vk.vk_alpha_1[0]);
console.log('  y:', vk.vk_alpha_1[1]);

console.log('\nbeta (G2):');
console.log('  x0:', vk.vk_beta_2[0][0]);
console.log('  x1:', vk.vk_beta_2[0][1]);
console.log('  y0:', vk.vk_beta_2[1][0]);
console.log('  y1:', vk.vk_beta_2[1][1]);

console.log('\ngamma (G2):');
console.log('  x0:', vk.vk_gamma_2[0][0]);
console.log('  x1:', vk.vk_gamma_2[0][1]);
console.log('  y0:', vk.vk_gamma_2[1][0]);
console.log('  y1:', vk.vk_gamma_2[1][1]);

console.log('\ndelta (G2):');
console.log('  x0:', vk.vk_delta_2[0][0]);
console.log('  x1:', vk.vk_delta_2[0][1]);
console.log('  y0:', vk.vk_delta_2[1][0]);
console.log('  y1:', vk.vk_delta_2[1][1]);

console.log('\nIC points (G1):');
vk.IC.forEach((ic, i) => {
    console.log(`  IC[${i}]:`);
    console.log(`    x: ${ic[0]}`);
    console.log(`    y: ${ic[1]}`);
});

// Save decimal values to JSON for easy import
const vkDecimal = {
    alpha: {
        x: vk.vk_alpha_1[0],
        y: vk.vk_alpha_1[1]
    },
    beta: {
        x0: vk.vk_beta_2[0][0],
        x1: vk.vk_beta_2[0][1],
        y0: vk.vk_beta_2[1][0],
        y1: vk.vk_beta_2[1][1]
    },
    gamma: {
        x0: vk.vk_gamma_2[0][0],
        x1: vk.vk_gamma_2[0][1],
        y0: vk.vk_gamma_2[1][0],
        y1: vk.vk_gamma_2[1][1]
    },
    delta: {
        x0: vk.vk_delta_2[0][0],
        x1: vk.vk_delta_2[0][1],
        y0: vk.vk_delta_2[1][0],
        y1: vk.vk_delta_2[1][1]
    },
    ic: vk.IC.map(ic => ({
        x: ic[0],
        y: ic[1]
    }))
};

const outputPath = path.join(buildDir, 'vk_decimal.json');
fs.writeFileSync(outputPath, JSON.stringify(vkDecimal, null, 2));
console.log(`\nDecimal VK saved to: ${outputPath}`);

console.log('\n');
console.log('=============================================');
console.log('DEPLOYMENT INSTRUCTIONS');
console.log('=============================================');
console.log(`
To deploy the Opaque contract, you need:

1. Deploy groth16_verifier first:
   stellar contract deploy \\
     --wasm target/wasm32v1-none/release/groth16_verifier.wasm \\
     --source-account alice \\
     --network testnet \\
     --alias groth16-verifier

2. Get the groth16_verifier contract ID from the output

3. Deploy the opaque contract with all parameters:
   stellar contract deploy \\
     --wasm target/wasm32v1-none/release/opaque.wasm \\
     --source-account alice \\
     --network testnet \\
     --alias opaque \\
     -- \\
     --vk_bytes <hex-encoded-vk> \\
     --token_address <native-xlm-or-token-contract> \\
     --admin <your-admin-address> \\
     --groth16_verifier <groth16-verifier-contract-id>

NOTE: The VK bytes need to be serialized in the format expected by the contract.
The contract's test.rs file contains an example of how to construct the VK.
`);
